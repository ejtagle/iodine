Detailed specification of protocol in version 00000801
======================================================

Note: The server and client implementations of iodine found alongside this
      documentation are implemented according to this specification. It is
      recommended to check the code in cases where the specification may be
      unclear. Where the wording may be ambiguous feel free to submit a pull
      request to improve it :)

Changes from 00000800 to 00000801:
 - Add HMAC-MD5 (truncated to 32 bits) to all data packets
   as checksum and authentication.
 - Add HMAC-MD5 (truncated to 96 bits) to all control packets
 - Improve CMC to be 32-bit incremental "replay protection counter"
 - Allow security level negotiation (enabled/disabled)
 - Increase size of login challenge
 - Add client to server login challenge
 - Remove ACKs entirely
 - Replace TCP forwarding with UDP forwarding and move to options command
 - Upstream data header now uses same encoding as data
 - Add HMAC to raw UDP protocol as well, simplifying raw login

======================================================
1. DNS protocol
======================================================

----------------------------------------
1.1 Quick alphabetical index / register:
----------------------------------------


	0-9	Data packet
	A-F	Data packet
	I	IP address
	K	Connection request
	L	Login
	N				(NS.topdomain A-type reply)
	O	Options
	P	Ping
	U	Codec check, authenticated
	V	Version
	W				(WWW.topdomain A-type reply)
	Y	Downstream codec check (DEPRECATED)

CMC = Cache Miss Counter, increased every time it is used

----------------------------------------------------------------------
1.2 Unauthenticated commands (pre-login), backwards compatibility only
----------------------------------------------------------------------

Note: The downstream codec and version checks are backwards-compatible with
previous versions of iodine, at least to protocol version 00000402.

Downstream codec check:
Client sends (no CMC+HMAC header):
	First byte y or Y
	Rest of query is ignored
Server sends (without downstream header):
	if qtype TXT: one byte 't'
	if qtype other but not NULL or PRIVATE: one byte 'h'
	unencoded (if NULL/PRIVATE) or base32 (others) DOWNCODECCHECK1 string
	as defined in encoding.h

-----------------
1.3 Login process
-----------------

Version:
Client sends (length 1+8):
	First byte v or V
	Rest encoded with base32:
	4 bytes big endian protocol version
	4 bytes random CMC
Server replies RAW (length 28, or 9 if bad version/full):
	1 char 's'
	4 chars:
		VACK (version ok), followed by login challenge
		VNAK (version differs), followed by server protocol version (see note)
		VFUL (server has no free slots), followed by max users
	4 byte value: means new userid/server protocol version/max users
	4 bytes random CMC
	16 byte server login challenge
Notes:
- Version replies from server use limited backwards compatible downstream
  header/encoding, and the client will accept at least base32 or raw encoded
  version replies (such as from older servers). See protocol 501 for details. 
- The CMC values are used as a "seed", so following the version command
  all queries must be sent with CMC of ((previous CMC + 1) % MAX_UINT32).
  The server response also contains random "downstream" CMC which has the same
  requirements, although only applies to downstream traffic.

Login:
Client sends (length 2+36):
	First byte l or L
	1 byte userid char (hex)
	Rest encoded with base32:
	4 bytes CMC
	16 bytes hash of password + server login challenge
	16 bytes client login challenge
Server replies (length 31):
	BADLOGIN if bad login
	16 bytes hash of password + client login challenge

The login process is outlined as follows:
	1. Successful version check; server provides a 16-byte login challenge to
		the client.
	2. The client performs MD5 hash of (server login challenge XOR MD5 hash of
		password). The client generates a random 16-byte client login challenge
		which is sent with the MD5 hash to the server in a login packet.
	3. The server performs MD5 hash of (server login challenge XOR MD5 hash of
		password) and replies to the login query. From this point onwards,
		all packets are signed with HMAC as described in section "Protocol
		security".

After successful login, the client should send a K (request data connection) to
get a TUN IP or open a forwarded UDP connection.

------------------------------------------------
1.4 Authenticated packets (after login complete)
------------------------------------------------

Command I: IP Request (for where to try raw login) (len=0)
	(no command-specific data)
Server replies (len=5-17):
	1 byte length of IP address (4 or 16)
	4 bytes (IPv4) or 16 bytes (IPv6) external IP address of server

Command K: Request data connection (UDP forward or TUN IP) (len=19)
	1 byte connection mode flags:
	    +76543210+	T flag: request TUN IP
	    |0000URIT|	URI = UDP forward flags
	    +--------+
	0-2 bytes remote UDP port (network byte order): 0 bytes if URI=0XX,
		2 bytes if URI=1XX
	0-16 bytes remote IP address: 0 bytes if URI=X00, 4 bytes if URI=110 (IPv4)
		or 16 bytes if URI=111 (IPv6)
Server replies: (len 1 or 11)
	BADOPTS if not accepted, no data follows
	1 byte copy of connection mode flags
	extra data if T flag is set:
	4 bytes server IPv4 address (network byte order)
	4 bytes client IPv4 address (network byte order)
	2 bytes MTU (network byte order)
	1 byte netmask bits (like CIDR)

	If UDP forwarding enabled, the client will not be allocated an IP on the
	server's TUN subnet. Instead data sent by the client will be sent as UDP
	packets to the specified port and IP address

Command U: Codec/length check (Note: irregular query/response format, see note)
	1 byte flags
    +76543210+
    |0000000D|		D:   Downstream (1) or Upstream (0) codec check
    +--------+
	1 byte length of upstream data = ULQ (before DNS-encode)
	2 bytes length of downstream data = DLQ
	<data of specified upstream data length = DATAQ>
Server replies (not quite normal downstream header):
	1 byte flags
    +76543210+		D:   Downstream (1) or Upstream (0) codec check
    |000000XD|		X:   EDNS0 option found (1) or not found (0)
    +--------+
	1 byte length of upstream data = ULR (after DNS-decode)
	2 bytes length of downstream data = DLR
	<data of specified downstream data length = DATAR>
Notes:
	- The HMAC in both query + reply signs only the 20 byte header + cmd/userid
	  (using the exact same process as other commands). BADHMAC can result.
	- Downstream codec check (D=1) means DATAQ is decoded as base32 by server.
	  Length of DATAQ to use is specified by ULQ, rest of DATAQ is ignored.
	  DATAR filled with decoded DATAQ repeated to be >= DLQ (excess truncated).
	  ULR is set to length of decoded DATAQ.
	  DLR is set to length of DATAR.
	- Upstream codec check (D=0) means DATAQ is encoded as base32 by server and
	  appended to reply data.
	  ULR is set to raw length of query as received.
	  DLR is set to length of DATAQ after base32 encode.
	- When testing maximum downstream length, DATAQ is filled so that question
	  name is as long as possible and DLQ indicates how much data is to be decoded
	  by server and echoed (repeated) in DATAR.

Command O: Set options (len 3)
	1 byte flags
    +76543210+
    |LKUUUCCC|
    +--------+
    2 bytes downstream fragsize
Server sends (len 3):
	BADOPTS if options rejected. Previous situation remains.
	1 byte flag byte sent by client if all options accepted
	2 bytes accepted downstream fragsize
Option flags:
	L:	Lazy mode enabled, server will keep a number of requests waiting until
		data becomes available to send downstream or the requests time out.
		The timeout value for requests is controlled by the client.
		Applies only to data transfer; handshake is always answered immediately.
		See section "Lazy mode operation".
	K:		Downstream data compression enabled (compressed before encoding)
	CCC:	Downstream data codec (for all authenticated replies)
	UUU:	Upstream codec (for all data packets)
	See codec types in section "Query and response format".
	Server may disregard the downstream codec options; client must always use
	the downstream encoding type indicated in every downstream DNS packet.
	After this downstream data length (after decoding) will be max (fragsize)
	bytes long.

--------------------------
1.5 Data packets and pings
--------------------------

Upstream data (len 1+(10-18)+data):
	1 char ASCII hex coded user ID
	rest encoded with chosen upstream codec (default base32):
	1 byte flags:
     76543210
    +--------+
    |0000HKFS|
    +--------+
    4 bytes CMC
    4-12 bytes HMAC
    1 byte packet sequence ID

Downstream data header (len 2+data):
	1 byte flags:
    +76543210+
    |PI000KFS|
    +--------+
    1 byte sequence ID
    <data>

Downstream ping reply header (len 9):
	1 byte flags:
    +76543210+
    |PI000000|
    +--------+
    4 bytes current server upstream CMC
    1 byte upstream windowsize
    1 byte downstream windowsize
    1 byte upstream window start sequence ID
    1 byte downstream window start sequence ID    

Flags and fields:
	I = responded to immediately (for RTT calculation) - downstream only
	P = ping flag: see "Downstream ping reply header"; data field is absent
	H = 1: 32-bit HMAC, 0: 96-bit HMAC (upstream only)
	K = Compression enabled
	F = First fragment flag
	S = Last fragment flag
	Up/Dn Wsize/Wstart = upstream/downstream window size/window start Seq ID 

Downstream data starts with 2 byte header, followed by data, which may be
compressed. If Ping flag is set, another 8 bytes are appended to the header,
containing the current CMC value of the client for downstream data, and the
upstream and downstream window sizes and window start sequence IDs.
The response may not contain any data following the ping header. If the server
has no data to send, it will always respond with downstream pings.

Command P: Ping / control message (len=4+13)
    +----------+76543210+
    |CCCCWWWWSS|00000WTR|
    +----------+--------+
    4 bytes client downstream CMC
	1 byte window size (upstream)
	1 byte window size (downstream)
	1 byte window start sequence ID (upstream)
	1 byte window start sequence ID (downstream)
	2 bytes server timeout in ms (net. byte order)
	2 bytes window timeout in ms (net. byte order)
	1 byte flags (00000WTR)
		W = update window frag timeout
		T = update server timeout
		R = response must contain ping header (data optional)
Server replies with a (possibly empty) data packet with the ping (P) flag set.
	If R (respond) bit is set, the server responds immediately with a data+ping packet.
	The server must also adjust its window sizes to those provided by the client.
	If the T flag is set, the server sets the user's DNS timeout to the value
	specified by the packet.

If the bit corresponding to changing a particular value (ie. server timeout) is
not set, the value of the field should be random.

In lazy mode, unless the R flag is set, the server will hold the ping until it
times out or more data becomes available to send.

-----------------------------
1.7 Query and response format
-----------------------------

The DNS answer header is independent from the command, unlike in upstream
packets. It varies based on the DNS response type, but the contents are always
in the same format once decoded.

In NULL and PRIVATE responses, downstream data (anything returned from the
server, not just data packets) is always raw. In all other response types,
downstream data is encoded (see Options above).

All post-authentication commands have same query hostname structure, except for
data packets and upstream codec commands. See above for details.
Client sends (length 2+16+...):
	1 byte cmd char (case insensitive)
	1 byte userid char (hexadecimal [0-9a-fA-F])
	Rest encoded in base32:
	4 bytes CMC
	12 bytes HMAC
	<command-specific data follows>
Standard server replies are as follows (including data):
	BADLEN (if packet length is invalid, ie. too short)
	BADAUTH (if user id/HMAC/CMC is invalid)
	(other error codes are command specific)
	
	1 char base32-encoded flags:
	 +98765+   H    = 0: HMAC is 96-bit, 1: 32-bit
	 |HECCC|   CCC  = Codec type (0-7)
	 +-----+   E    = 0: no error, 1: Codec field = error code
	Rest encoded with specified codec:
	4 bytes CMC (network byte order)
	4 or 12 bytes HMAC (note: HMAC field is 32-bits random for all pre-login responses)
	<command-specific data follows>

Encoding is determined by the value of the codec field for all responses. Note
that all query types support all codecs.
TXT response type:
	Encoded data is split into len-prefixed strings (see RFC 1035 for TXT RDATA
	format) which are appended to each other in the TXT RDATA section. 
CNAME/DNAME/A/AAAA/PTR/A6 response type:
	Encoded data is split into len-prefixed DNS labels (see RFC 1035 for DNS
	hostname format) as a valid DNS hostname. Thus data must be <255 or so bytes
	long. A6 response (see RFC 2874) has extra "prefix" byte at beginning of
	RDATA which is always set to 128. 
SRV/MX response type: (see RFC 1035 for MX RDATA, RFC 2782 for SRV RDATA)
	Encoded data is split into multiple valid DNS hostnames which are put into
	separate SRV/MX RRs. Each RR has a 10-multiple priority, and en/decoding is
	done in strictly increasing priority sequence 10, 20, 30, etc. Note that
	some DNS relays will shuffle the answer records in the response. SRV RRs
	include port (always 5060) and weight (always 10).
NULL/PRIVATE response type:
	Encoded data is pasted as-is into RDATA field.

Codec field values:
	0x0: raw      (\000-\377)
	0x1: base64   (a-zA-Z0-9+-)
	0x2: base32   (a-z0-5)
	0x3: base64u  (a-zA-Z0-9_-)
	0x4: base128  (a-zA-Z0-9\274-\375)
Error codes:
	0x0: BADLEN (packet below minimum length, maybe truncated)
	0x1: BADAUTH (invalid authentication/HMAC/CMC)
	0x2: BADOPTS (options not accepted by server)
	0x3: BADLOGIN (LNAK: login not accepted)

Protocol security
=================

With the introduction of protocol 00000801, iodine now requires all packets
sent from both the server and clients after a successful login to include a
32-bit (incremental) replay-protection counter and be signed with a 32- or
96-bit (truncated) HMAC-MD5 digest. This aims to ensure that the packets have
not been modified or corrupted during transmission, and to provide some
protection against replay attacks. Additionally the HMAC makes it possible
to check if packets have been truncated by intermediate DNS servers.

The HMAC component of the authentication is calculated using the HMAC-MD5 algorithm
according to RFC 2104. The key is calculated according to the following process:
	1. Calculate MD5(plaintext password)
	2. Calculate MD5(server challenge)
	3. Calculate MD5(client challenge)
	4. Append result from (2) to result from (1)
	5. Append result from (3) to result from (4) and pad with 0x2C to 64 bytes
	6. Bitwise XOR result from (5) with 0xB5
	7. Calculate the MD5 hash of the result from (6), this is the key for the HMAC.

The HMAC is calculated as follows for queries:
	1. Packet data and header is assembled (data is not encoded yet).
	2. HMAC field is set to 0.
	3. Data to be encoded is appended to string (ie. cmd + userid chars) at
		beginning of query name.
	4. Length (32 bits, network byte order) is prepended to the result from (3)
		Length = (len of chars at start of query) + (len of raw data) 
	5. HMAC is calculated using the output from (4) and inserted into the HMAC
		field in the data header. The data is then encoded (ie. base32 + dots)
		and the query is sent.

HMAC for responses is calculated following mostly the same procedure with the
following notes:
	- Data includes only that to be encoded in the DNS answer section
	- In step (3) the data to be encoded is appended to the 1-char (b32)
		downstream header.
It should be noted that the codec used is not signed by the HMAC. This would mean
that if the data was intercepted and reencoded differently in such a way that
iodine was still able to decode it, the HMAC would still be valid.

Since iodine authentication is based on MD5, which can no longer be considered
to be cryptographically secure, it is not possible to claim that the protocol
is resistant to tampering. Furthermore, it is likely that 32-bit HMACs are not
sufficient using any algorithm to guarantee the authenticity of the data.
While the addition of HMAC in protocol 00000801 may provide some level of security,
it does not provide any guarantee that your iodine session can not be hijacked
and is not intended to give peace of mind to the iodine user.

Replay protection existed in previous versions of the protocol in the form of
the CMC (Cache Miss Counter) however this functions primarily to prevent DNS
servers from sending cached replies to iodine queries. This source of packet
replays is limited to some degree by the use of the CMC but since neither the
client or server keeps track of which CMC values have been seen before, so it
remains possible that intermediate DNS servers will repeat queries (with a
valid HMAC) that can disrupt iodine sessions.
Possibly the simplest way to avoid this is to include a 32-bit incremental
CMC in the packet header which can easily be tested to be unique based on
whether or not packets have been seen with higher CMC values. 


"Lazy-mode" operation
=====================

Client-server DNS traffic sequence has been reordered to provide increased
(interactive) performance and greatly reduced latency.

Idea taken from Lucas Nussbaum's slides (24th IFIP International Security
Conference, 2009) at http://www.loria.fr/~lnussbau/tuns.html. Current
implementation is original to iodine, no code or documentation from any other
project was consulted during development.

Server:
In lazy mode, except where otherwise specified, responses are sent using the
oldest pending query held in the server's buffer (QMEM). The server responds
to a stored pending query when the query times out, an upstream ACK is pending
(for that user), or the server has an excess of pending queries (more than the
user's downstream window size).

Upstream data fragments are ACK'd immediately to keep data flowing.

Upstream pings are answered immediately only when the Respond flag is set (see
ping header), in which case the response is to the same DNS query as the ping.
Immediate responses (<10ms old) to either ping or data requests are marked
and used to calculate the round-trip-time for the connection.

Client:
The client keeps track of all queries it sends, and maintains a minimum of
<downstream window size> pending queries to fill the server buffer.
Downstream data is always ACK'd immediately with a new request (either a ping
or data if available). The client sends excess requests (ie. already has enough
pending queries) for ACKs or for new data.


======================================================
2. Raw UDP protocol
======================================================

This protocol is faster since the data is not encoded and transferred
on top of the DNS protocol. Full packets are compressed and sent when they
arrive on the tun device, and are processed immediately on the other side.

All Raw UDP protcol messages start with a fixed-length 20-byte header.
This is not the start of a valid DNS message so it is easy to identify.

Raw UDP Header (len=20):
	3 bytes magic:  0x10d19e
	1 byte command (4-bits C) and user id (4-bits U):
		 7654 3210
		+----+----+
		|CCCC|UUUU|
		+----+----+	
	4 bytes CMC/relay protection counter
	12 bytes HMAC

Login message (command = 1):
	16 bytes random data
	This message can only be sent after the full DNS-based login sequence has been
	completed successfully. The client enters raw mode by sending this message,
	which must be signed using the client's 96-bit HMAC.
	After the login message has been exchanged, both the server and the client
	switch to raw udp mode for the rest of the connection.

Data message (command = 2):
	After the header comes the payload data, which is always compressed.

Ping message (command = 3):
	Sent from client to server and back to keep session open. Has no payload.

